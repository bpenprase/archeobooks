<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>archeo2.db browser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 1.5rem; color:#222; }
    header { display: flex; flex-wrap: wrap; gap: .75rem; align-items: baseline; margin-bottom: 0.75rem; }
    #status { font-size: .95rem; color: #444; }

    input[type="text"], button { padding: .45rem .6rem; font-size: 0.95rem; }
    input[type="text"] { min-width: 16rem; }
    button { cursor: pointer; }

    .toolbar { display: flex; flex-wrap: wrap; gap: .5rem; align-items: center; margin: .5rem 0 .25rem; }

    table { border-collapse: collapse; width: 100%; table-layout: auto; margin-top: 0.5rem; }
    th, td {
      border: 1px solid #ddd; padding: 8px; vertical-align: top;
      word-break: normal; overflow-wrap: break-word; white-space: normal; line-height: 1.35;
    }
    thead th { position: sticky; top: 0; background: #fafafa; }
    tbody tr:nth-child(even) { background: #fcfcfc; }

    /* Column widths (by display label) */
    .col-select  { width: 3ch; text-align: center; }
    .col-title   { width: 30ch; }
    .col-author  { width: 24ch; }
    .col-keywords{ width: 28ch; }
    .col-year    { width: 10ch; text-align: center; }
    .col-pages   { width: 10ch; text-align: center; }
    .col-summary { min-width: 60ch; max-width: 120ch; }

    .muted { color:#666; font-size:.92rem; }
    form.search { display:flex; flex-wrap:wrap; gap:.5rem; margin-bottom:.5rem; align-items:center; }
    form.search label { display:flex; gap:.35rem; align-items:center; font-weight:600; }
    form.search label input { font-weight:400; }
  </style>
</head>
<body>
  <header>
    <h1 style="margin:0;">archeo2.db</h1>
    <div id="status">Loading…</div>
  </header>

  <div class="toolbar">
    <button id="exportBtn" disabled>Output selected results (CSV)</button>
    <button id="exportAllBtn" disabled>Download all results (CSV)</button>
    <span class="muted">Showing: Title, Author, Keywords, Year, Pages, Summary • Search is case-insensitive; commas = OR</span>
  </div>

  <form id="searchForm" class="search" onsubmit="return false;">
    <label>Author <input id="authorInput" type="text" disabled /></label>
    <label>Title <input id="titleInput" type="text" disabled /></label>
    <label>Keywords <input id="keywordsInput" type="text" disabled /></label>
    <label>Any <input id="anyInput" type="text" disabled /></label>
    <button id="searchBtn" disabled>Search</button>
    <button id="clearBtn" disabled>Clear</button>
  </form>

  <div id="out"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.11.0/sql-wasm.js"></script>
  <script>
  const DB_URL = "https://raw.githubusercontent.com/bpenprase/archeobooks/main/archeo2.db";
  const ROW_LIMIT = 500;

  // Desired display order/labels + flexible aliases in your DB
  const DISPLAY_SPEC = [
    { label: "Title",   aliases: ["title","book_title","name"] },
    { label: "Author",  aliases: ["author","authors","creator","writer"] },
    { label: "Keywords",aliases: ["keywords","tags","subjects","subject","key_words","descriptors"] },
    { label: "Year",    aliases: ["year","pub_year","publication_year","year_published","date_year"] },
    { label: "Pages",   aliases: ["pages","pagecount","page_count","pgs","num_pages","extent"] },
    { label: "Summary", aliases: ["summary","abstract","description","notes"] },
  ];

  const els = {
    status: document.getElementById('status'),
    out: document.getElementById('out'),
    author: document.getElementById('authorInput'),
    title: document.getElementById('titleInput'),
    keywords: document.getElementById('keywordsInput'),
    any: document.getElementById('anyInput'),
    searchBtn: document.getElementById('searchBtn'),
    clearBtn: document.getElementById('clearBtn'),
    exportBtn: document.getElementById('exportBtn'),
    exportAllBtn: document.getElementById('exportAllBtn'),
  };

  let SQL, db, tableName;

  // current rendered data & selection
  let currentColumns = [];  // array of display labels in order
  let currentRows = [];     // array of rows as {Title:..., Author:..., ...}
  const selected = new Set(); // indices of selected rows

  function setStatus(msg){ els.status.textContent = msg; }
  function escapeLike(s){ return s.replace(/([\\%_])/g,"\\$1"); }

  async function fetchDB(url){
    const resp = await fetch(url, { cache:"no-store" });
    if(!resp.ok) throw new Error("Failed to fetch DB: "+resp.status);
    return new Uint8Array(await resp.arrayBuffer());
  }

  function buildColumnResolver(allCols){
    // Map lowercased DB column -> original case
    const lcToOrig = new Map(allCols.map(c => [c.toLowerCase(), c]));
    // For each desired display label, pick the first alias that exists in DB
    const resolved = DISPLAY_SPEC.map(spec => {
      for (const a of spec.aliases) {
        const hit = lcToOrig.get(a.toLowerCase());
        if (hit) return { label: spec.label, dbcol: hit };
      }
      return null; // not present in this DB
    }).filter(Boolean);
    return resolved; // [{label, dbcol}, ...] in desired order
  }

  function renderTable(resolvedCols, rowObjs){
    // rowObjs are objects keyed by display label
    currentColumns = resolvedCols.map(rc => rc.label);
    currentRows = rowObjs;
    selected.clear();
    els.exportBtn.disabled = currentRows.length === 0;
    els.exportAllBtn.disabled = currentRows.length === 0;

    const table = document.createElement('table');

    const tbody = document.createElement('tbody');
    const thead = document.createElement('thead');
    const hrow = document.createElement('tr');

    // select-all
    const thSel = document.createElement('th');
    thSel.className = "col-select";
    const selAll = document.createElement('input');
    selAll.type = 'checkbox'; selAll.title = "Select all";
    selAll.addEventListener('change', () => {
      selected.clear();
      if (selAll.checked) for (let i = 0; i < rowObjs.length; i++) selected.add(i);
      tbody.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = selAll.checked);
      selAll.indeterminate = false;
      els.exportBtn.disabled = selected.size === 0;
    });
    thSel.appendChild(selAll);
    hrow.appendChild(thSel);

    // headers with display labels
    resolvedCols.forEach(({label}) => {
      const th = document.createElement('th');
      th.textContent = label;
      th.className = "col-" + label.toLowerCase();
      hrow.appendChild(th);
    });
    thead.appendChild(hrow); table.appendChild(thead);

    // rows
    rowObjs.forEach((row, idx) => {
      const tr = document.createElement('tr');

      const tdSel = document.createElement('td');
      tdSel.className = "col-select";
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.addEventListener('change', () => {
        if (cb.checked) selected.add(idx); else selected.delete(idx);
        if (selected.size === rowObjs.length) { selAll.checked = true; selAll.indeterminate = false; }
        else if (selected.size === 0) { selAll.checked = false; selAll.indeterminate = false; }
        else { selAll.checked = false; selAll.indeterminate = true; }
        els.exportBtn.disabled = selected.size === 0;
      });
      tdSel.appendChild(cb);
      tr.appendChild(tdSel);

      resolvedCols.forEach(({label}) => {
        const td = document.createElement('td');
        td.textContent = row[label] ?? "";
        td.className = "col-" + label.toLowerCase();
        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    els.out.innerHTML = "";
    els.out.appendChild(table);
  }

  function toCSV(rows, columns){
    const esc = v => {
      const s = (v == null ? "" : String(v));
      if (/["\n,]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    };
    const header = columns.map(esc).join(",");
    const body = rows.map(r => columns.map(c => esc(r[c])).join(",")).join("\n");
    return header + "\n" + body;
  }

  function downloadCSV(rows, columns, prefix){
    const csv = toCSV(rows, columns);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
    a.href = url; a.download = `${prefix}-${ts}.csv`;
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function exportSelected(){
    if (selected.size === 0) return;
    const indices = Array.from(selected).sort((a,b)=>a-b);
    const rows = indices.map(i => currentRows[i]);
    downloadCSV(rows, currentColumns, "archeobooks-selected");
  }

  function exportAll(){
    if (!currentRows.length) return;
    downloadCSV(currentRows, currentColumns, "archeobooks-all-results");
  }

  function buildWhereAndParams(colmap, fields){
    const whereParts = [];
    const params = [];
    // Find actual DB columns for Author/Title/Keywords using aliases
    const findByAliases = (aliases) => {
      for (const a of aliases) {
        const hit = colmap[a.toLowerCase()];
        if (hit) return hit;
      }
      return null;
    };

    const authorCol   = findByAliases(["author","authors","creator","writer"]);
    const titleCol    = findByAliases(["title","book_title","name"]);
    const keywordsCol = findByAliases(["keywords","tags","subjects","subject","key_words","descriptors"]);

    const addOrGroup = (dbcol, raw) => {
      if (!dbcol || !raw || !raw.trim()) return;
      const parts = raw.split(",").map(s=>s.trim()).filter(Boolean);
      if (!parts.length) return;
      whereParts.push("(" + parts.map(()=>`lower("${dbcol}") LIKE ? ESCAPE '\\'`).join(" OR ") + ")");
      parts.forEach(p => params.push("%"+escapeLike(p.toLowerCase())+"%"));
    };

    addOrGroup(authorCol, fields.author);
    addOrGroup(titleCol, fields.title);
    addOrGroup(keywordsCol, fields.keywords);

    if (fields.any && fields.any.trim()){
      // Any searches across Title/Author/Keywords; if any missing, skip them
      const anyCols = [titleCol, authorCol, keywordsCol].filter(Boolean);
      const parts = fields.any.split(",").map(s=>s.trim()).filter(Boolean);
      // Require all terms (AND); each term can match any of the anyCols (OR)
      parts.forEach(term => {
        const ors = anyCols.map(c => `lower("${c}") LIKE ? ESCAPE '\\'`).join(" OR ");
        params.push(...Array(anyCols.length).fill("%"+escapeLike(term.toLowerCase())+"%"));
        whereParts.push("(" + ors + ")");
      });
    }

    const where = whereParts.length ? "WHERE " + whereParts.join(" AND ") : "";
    return { where, params };
  }

  function runSearch(){
    const fields = {
      author: els.author.value.trim(),
      title: els.title.value.trim(),
      keywords: els.keywords.value.trim(),
      any: els.any.value.trim()
    };

    // Inspect table schema
    const pragma = db.exec(`PRAGMA table_info("${tableName}")`);
    const colmap = {}; // lc -> original
    pragma[0].values.forEach(r => { colmap[r[1].toLowerCase()] = r[1]; });

    // Build WHERE
    const { where, params } = buildWhereAndParams(colmap, fields);

    // Query rows (limit for UI speed)
    const sql = `SELECT * FROM "${tableName}" ${where} LIMIT ${ROW_LIMIT};`;
    const stmt = db.prepare(sql); if (params.length) stmt.bind(params);

    const rawRows = []; while (stmt.step()) rawRows.push(stmt.getAsObject()); stmt.free();

    if (!rawRows.length){
      els.out.textContent = "No matches.";
      setStatus("No matches.");
      els.exportBtn.disabled = true;
      els.exportAllBtn.disabled = true;
      currentColumns = []; currentRows = []; selected.clear();
      return;
    }

    // Decide display columns (map aliases -> actual DB columns)
    const allCols = Object.keys(rawRows[0]); // columns present in result set
    const resolved = buildColumnResolver(allCols); // [{label, dbcol}, ...]

    // Build rows for rendering keyed by display label
    const viewRows = rawRows.map(r => {
      const o = {};
      resolved.forEach(({label, dbcol}) => { o[label] = r[dbcol]; });
      return o;
    });

    renderTable(resolved, viewRows);
    setStatus("Found " + rawRows.length + " match(es).");
  }

  async function main(){
    setStatus("Loading engine…");
    const SQLMod = await initSqlJs({ locateFile: f=>`https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.11.0/${f}` });
    SQL = SQLMod;
    const bytes = await fetchDB(DB_URL);
    db = new SQL.Database(bytes);

    // pick first user table
    const tables = db.exec(`SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name;`);
    tableName = tables[0].values[0][0];

    // enable UI
    [els.author,els.title,els.keywords,els.any,els.searchBtn,els.clearBtn].forEach(el=>el.disabled=false);
    els.exportBtn.disabled = true;
    els.exportAllBtn.disabled = true;

    els.searchBtn.onclick = runSearch;
    els.clearBtn.onclick  = () => { els.author.value = els.title.value = els.keywords.value = els.any.value = ""; runSearch(); };
    els.exportBtn.onclick = exportSelected;
    els.exportAllBtn.onclick = exportAll;
    [els.author,els.title,els.keywords,els.any].forEach(inp => {
      inp.addEventListener("keydown", e => { if (e.key === "Enter") runSearch(); });
    });

    // initial (no filters)
    runSearch();
  }

  main().catch(e => { setStatus("Error: " + e.message); console.error(e); });
  </script>
</body>
</html>

