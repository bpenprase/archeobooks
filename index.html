<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>archeo2.db browser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --pad: 12px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 1.5rem; color:#222; }
    header { display: flex; flex-wrap: wrap; gap: .75rem; align-items: baseline; margin-bottom: 0.75rem; }
    #status { font-size: .95rem; color: #444; }
    .row { display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; }
    label { font-weight:600; }
    input[type="text"], select, button { padding: .45rem .6rem; font-size: 0.95rem; }
    input[type="text"] { min-width: 16rem; }
    button { cursor:pointer; }
    hr { border:none; border-top:1px solid #ddd; margin: 1rem 0; }

    /* NEW: scroll container to avoid squishing columns too much */
    .table-wrap { overflow-x: auto; }

    /* NEW: let the browser size columns naturally */
    table { border-collapse: collapse; width: 100%; table-layout: auto; }
    th, td {
      border: 1px solid #ddd; padding: var(--pad); vertical-align: top;
      /* NEW: prefer breaking at words; only break long tokens if needed */
      overflow-wrap: break-word; word-break: normal; white-space: normal; line-height: 1.35;
    }
    thead th { position: sticky; top: 0; background: #fafafa; z-index: 1; }
    tbody tr:nth-child(even) { background: #fcfcfc; }

    /* Widen long-text columns by name (lowercased CSS class col-<name>) */
    /* NEW: give summary a reasonable min width and allow wrapping */
    .col-summary, .col-abstract, .col-description {
      min-width: 60ch; max-width: 110ch; hyphens: auto;
    }
    .col-title { width: 36ch; }
    .col-author, .col-authors { width: 28ch; }
    .muted { color:#666; font-size:.92rem; }
  </style>
</head>
<body>
  <header>
    <h1 style="margin:0;">archeo2.db</h1>
    <div id="status">Loading…</div>
  </header>

  <div class="row" style="gap:.75rem; margin-bottom:.5rem;">
    <label for="tableSelect">Table:</label>
    <select id="tableSelect" disabled></select>
    <button id="showAllBtn" disabled>Show all</button>
    <span class="muted">Showing up to <code id="limitSpan">500</code> results</span>
  </div>

  <form id="searchForm" onsubmit="return false;" style="display:grid; grid-template-columns: auto 1fr auto; gap:.5rem; align-items:center;">
    <label for="authorInput">Author</label>
    <input id="authorInput" type="text" placeholder="e.g., Chumash scholar" disabled />
    <button id="authorClear" type="button" disabled>×</button>

    <label for="titleInput">Title</label>
    <input id="titleInput" type="text" placeholder="e.g., Mayan astronomy" disabled />
    <button id="titleClear" type="button" disabled>×</button>

    <label for="keywordsInput">Keywords</label>
    <input id="keywordsInput" type="text" placeholder="e.g., Mayan, Chumash" disabled />
    <button id="keywordsClear" type="button" disabled>×</button>

    <label for="anyInput">Any</label>
    <input id="anyInput" type="text" placeholder="Search across Author/Title/Keywords" disabled />
    <button id="anyClear" type="button" disabled>×</button>
  </form>

  <div class="row" style="gap:.5rem; margin-top:.5rem;">
    <button id="searchBtn" disabled>Search</button>
    <button id="clearBtn" disabled>Clear all</button>
    <span class="muted">Search is case-insensitive and uses partial matching. Comma-separated terms use OR logic within a field.</span>
  </div>

  <hr/>
  <!-- NEW: wrap results table in a scroll container -->
  <div class="table-wrap" id="tableWrap">
    <div id="out"></div>
  </div>

  <!-- sql.js: defines global initSqlJs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.11.0/sql-wasm.js"></script>
  <script>
  const DB_URL = "https://raw.githubusercontent.com/bpenprase/archeobooks/main/archeo2.db";
  const ROW_LIMIT = 500;
  document.getElementById('limitSpan').textContent = ROW_LIMIT;

  const els = {
    status: document.getElementById('status'),
    out: document.getElementById('out'),
    tableSelect: document.getElementById('tableSelect'),
    showAllBtn: document.getElementById('showAllBtn'),
    author: document.getElementById('authorInput'),
    title: document.getElementById('titleInput'),
    keywords: document.getElementById('keywordsInput'),
    any: document.getElementById('anyInput'),
    authorClear: document.getElementById('authorClear'),
    titleClear: document.getElementById('titleClear'),
    keywordsClear: document.getElementById('keywordsClear'),
    anyClear: document.getElementById('anyClear'),
    searchBtn: document.getElementById('searchBtn'),
    clearBtn: document.getElementById('clearBtn'),
  };

  let SQL, db;
  const tableCols = new Map();

  const COL_ALIASES = {
    author:   ["author","authors","creator","writer"],
    title:    ["title","book_title","name"],
    keywords: ["keywords","tags","subjects","subject","key_words","descriptors"]
  };

  function setStatus(msg){ els.status.textContent = msg; }
  function escapeLike(s){ return s.replace(/([\\%_])/g,"\\$1"); }

  async function fetchDB(url){
    const resp = await fetch(url, { cache: "no-store" });
    if (!resp.ok) throw new Error("Failed to fetch DB (" + resp.status + ")");
    return new Uint8Array(await resp.arrayBuffer());
  }

  function renderTable(columns, values){
    const table = document.createElement('table');

    const thead = document.createElement('thead');
    const hrow = document.createElement('tr');
    columns.forEach(col => {
      const th = document.createElement('th');
      th.textContent = col;
      th.className = `col-${col.toLowerCase()}`;
      hrow.appendChild(th);
    });
    thead.appendChild(hrow);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    values.forEach(row => {
      const tr = document.createElement('tr');
      row.forEach((cell, i) => {
        const td = document.createElement('td');
        td.textContent = (cell == null) ? "" : String(cell);
        td.className = `col-${columns[i].toLowerCase()}`;
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    els.out.innerHTML = "";
    els.out.appendChild(table);
  }

  function getColumnsForTable(tableName){
    if (tableCols.has(tableName)) return tableCols.get(tableName);
    const res = db.exec(`PRAGMA table_info("${tableName}");`);
    const rows = res[0]?.values || [];
    const cols = rows.map(r => ({ name: String(r[1]), type: String(r[2] || "") }));
    tableCols.set(tableName, cols);
    return cols;
  }

  function findColumnByAliases(tableName, aliasList){
    const cols = getColumnsForTable(tableName);
    const lcToOrig = new Map(cols.map(c => [c.name.toLowerCase(), c.name]));
    for (const alias of aliasList){
      const hit = lcToOrig.get(alias.toLowerCase());
      if (hit) return hit;
    }
    return null;
  }

  function getSearchableTextColumns(tableName){
    const cols = getColumnsForTable(tableName);
    const texty = cols.filter(c => /CHAR|CLOB|TEXT/i.test(c.type || ""));
    return (texty.length ? texty : cols).map(c => c.name);
  }

  function listAll(tableName){
    setStatus(`Listing ${tableName}…`);
    const res = db.exec(`SELECT * FROM "${tableName}" LIMIT ${ROW_LIMIT};`);
    if (!res || !res[0]) { els.out.innerHTML=""; setStatus("No rows."); return; }
    const { columns, values } = res[0];
    renderTable(columns, values);
    setStatus(`Showing ${values.length} row(s) from ${tableName}.`);
  }

  function buildWhereAndParams(tableName, fields){
    const whereParts = [];
    const params = [];

    const colAuthor   = findColumnByAliases(tableName, COL_ALIASES.author);
    const colTitle    = findColumnByAliases(tableName, COL_ALIASES.title);
    const colKeywords = findColumnByAliases(tableName, COL_ALIASES.keywords);

    function addOrGroupForColumn(colName, raw){
      if (!colName || !raw || !raw.trim()) return;
      const terms = raw.split(",").map(s=>s.trim()).filter(Boolean);
      if (terms.length === 0) return;
      const ors = terms.map(()=> `lower(coalesce("${colName}", '')) LIKE ? ESCAPE '\\'`);
      whereParts.push(`(${ors.join(" OR ")})`);
      terms.forEach(t => params.push(`%${escapeLike(t.toLowerCase())}%`));
    }

    addOrGroupForColumn(colAuthor, fields.author);
    addOrGroupForColumn(colTitle, fields.title);
    addOrGroupForColumn(colKeywords, fields.keywords);

    if (fields.any && fields.any.trim()){
      const terms = fields.any.split(",").map(s=>s.trim()).filter(Boolean);
      const cols = [colAuthor, colTitle, colKeywords].filter(Boolean);
      const colsAny = cols.length ? cols : getSearchableTextColumns(tableName);
      const anyGroup = terms.map(term => {
        const ors = colsAny.map(c => `lower(coalesce("${c}",'')) LIKE ? ESCAPE '\\'`).join(" OR ");
        params.push(...Array(colsAny.length).fill(`%${escapeLike(term.toLowerCase())}%`));
        return `(${ors})`;
      }).join(" AND ");
      whereParts.push(`(${anyGroup})`);
    }

    const whereClause = whereParts.length ? `WHERE ${whereParts.join(" AND ")}` : "";
    return { whereClause, params };
  }

  function runSearch(tableName, fields){
    const { whereClause, params } = buildWhereAndParams(tableName, fields);
    const sql = `SELECT * FROM "${tableName}" ${whereClause} LIMIT ${ROW_LIMIT};`;

    const stmt = db.prepare(sql);
    if (params.length) stmt.bind(params);

    const columns = []; let colsCaptured = false;
    const values = [];
    while (stmt.step()){
      const row = stmt.getAsObject();
      if (!colsCaptured){
        Object.keys(row).forEach(k => columns.push(k));
        colsCaptured = true;
      }
      values.push(columns.map(k => row[k]));
      if (values.length >= ROW_LIMIT) break;
    }
    stmt.free();

    if (values.length === 0){
      els.out.innerHTML = "";
      setStatus("No matches.");
      return;
    }
    renderTable(columns, values);
    setStatus(`Found ${values.length} match(es).`);
  }

  async function main(){
    setStatus("Loading SQL engine…");
    const SQLMod = await initSqlJs({
      locateFile: f => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.11.0/${f}`
    });
    SQL = SQLMod;

    setStatus("Fetching database…");
    const bytes = await fetchDB(DB_URL);

    setStatus("Opening database…");
    db = new SQL.Database(bytes);

    const tablesRes = db.exec(`
      SELECT name FROM sqlite_master
      WHERE type='table' AND name NOT LIKE 'sqlite_%'
      ORDER BY name COLLATE NOCASE;
    `);
    if (!tablesRes.length || !tablesRes[0].values.length){
      setStatus("No tables found.");
      return;
    }
    const tables = tablesRes[0].values.map(v => v[0]);
    const defaultTable = tables.includes('books') ? 'books' : tables[0];

    els.tableSelect.innerHTML = "";
    tables.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t; opt.textContent = t;
      if (t === defaultTable) opt.selected = true;
      els.tableSelect.appendChild(opt);
    });

    [
      els.tableSelect, els.showAllBtn,
      els.author, els.title, els.keywords, els.any,
      els.authorClear, els.titleClear, els.keywordsClear, els.anyClear,
      els.searchBtn, els.clearBtn
    ].forEach(el => el.disabled = false);

    listAll(defaultTable);

    els.tableSelect.addEventListener('change', () => {
      els.author.value = els.title.value = els.keywords.value = els.any.value = "";
      listAll(els.tableSelect.value);
    });
    els.showAllBtn.addEventListener('click', () => {
      els.author.value = els.title.value = els.keywords.value = els.any.value = "";
      listAll(els.tableSelect.value);
    });

    els.authorClear.onclick = () => els.author.value = "";
    els.titleClear.onclick = () => els.title.value = "";
    els.keywordsClear.onclick = () => els.keywords.value = "";
    els.anyClear.onclick = () => els.any.value = "";

    els.clearBtn.addEventListener('click', () => {
      els.author.value = els.title.value = els.keywords.value = els.any.value = "";
      listAll(els.tableSelect.value);
    });

    function doSearch(){
      runSearch(els.tableSelect.value, {
        author: els.author.value,
        title: els.title.value,
        keywords: els.keywords.value,
        any: els.any.value
      });
    }
    els.searchBtn.addEventListener('click', doSearch);
    [els.author, els.title, els.keywords, els.any].forEach(inp => {
      inp.addEventListener('keydown', e => { if (e.key === 'Enter') doSearch(); });
    });
  }

  main().catch(err => { setStatus("Error: " + err.message); console.error(err); });
  </script>
</body>
</html>

